{
  "title": "CS50 学習メモ",
  "closed": false,
  "archived": false,
  "created_at": "2021-11-06",
  "comments": [
    {
      "author": "nyarufoy",
      "created_at": "2021-11-06",
      "body_markdown": "# 概要\n\n[CS50](https://cs50.jp/)の学習メモである\n毎回の講義の重要キーワード、また学習の備忘録を記載していく\n\nhttps://online-learning.harvard.edu/course/cs50-introduction-computer-science?delta=0\nhttps://cs50.jp/\n",
      "body_updated_at": "2021-12-03"
    },
    {
      "author": "nyarufoy",
      "created_at": "2021-11-06",
      "body_markdown": "# Lecture0\n[CS50 Lecture0 Scratch](https://www.youtube.com/watch?v=pLuwGw_RXRs&t=1973s)\n\n# 重要キーワード\n- バイナリ(binary)\n2進法(基数を2とした0または1)で記載された数のことである\nバイナリとは、2進数のという意味の英語である\n私たちが普段使っている、10進数の2は2進数で10となる\n- 二進法\n2進法とは、数を書き表す方法の一つで、基数を2(0または1)とした表現方法のことを指す\nコンピュータ上ではテキストや画像も、0と1で表現できる形式に変換されて保存されている\n- ビット\nコンピューターで扱う最小のデータ単位のこと\n0または1を入れる箱(1桁分)のことをビット(bit)と呼ぶ\nn進数 = 箱の大きさがn-1 = 使う数字がn個\n1ビットは2の1乗、2ビットは2の2乗、3ビットは2の3乗通り表現する事ができ、\n2進数の3ビット(0~7)で表現できるのは、2*2*2=8 8通りとなる\n- バイト\nビットが8個集まったものがバイトと呼ばれる 8bit = 1byte\n- ASCII\n米国規格協会（ANSI）によって定められた、コンピューターの情報交換用の標準コード\nASCIIはテキストをバイナリで表現する一つの決まりごととなる\n世の中の言語を表現できるように拡張されたのがユニコード(Unicode)\nRGB の比率を調整して、1byteで256通りの値が取れるので、大体の色のバリエーションを表現する事が可能\nパーツ1つをピクセルと言い、それを集合させることで画像を表現する事ができる\n\n- アルゴリズム\nある結果を出力するためのやり方、計算方法のことである\nプログラムを書くときは、基本的には正確性を優先し、その上で効率を考慮する事が大事である\n\n- 関数\n関数とは、コンピュータに何かをさせるための命令の集合である\n- 変数\n変数とは、一時的にデータ(値)を格納しておくための仕組みである\n\n",
      "body_updated_at": "2021-11-06"
    },
    {
      "author": "nyarufoy",
      "created_at": "2021-11-13",
      "body_markdown": "# Lecture1\n[CS50 Lecture1 C](https://youtu.be/JBu-F9S7cQo)\n\n# 重要キーワード\n\n- CUI\nキャラクターユーザインターフェース(Character-based User Interface)の略\nキャラクターとは、文字という意味であり、名前通り、文字で操作するインターフェースのことである\nインターフェースとは、画面のことであり、ユーザーが操作する部分を表している\n例として、cmd(コマンドプロンプト)が挙げられる\n\n- GUI\nグラフィカルユーザーインターフェース(Graphical User Interface)の略\nグラフィカルとは、絵画的という意味であり、\nボタンであったり、マウス操作などを用いて感覚的に操作することを可能としている\nスマートフォンや、pcの画面、ほとんどのものがGUIとなる\n\n\n- コンパイラ、コンパイル\nコンパイラとは、人間が書いたソースコードをコンピュータがわかるように機械語に変化するプログラムのこと\nまた、Cなどのプログラミング言語を機械語(バイナリー)に事前に一括して翻訳することをコンパイルと呼ぶ\nコンパイラによって変換されるプログラミング言語のことをコンパイラ言語とも呼ぶ\n例として、C言語、C++、Javaなどが挙げられる\nそれに対して、Python、JavaScriptなど一行ずつ翻訳を行うことをインタープリタと呼ぶ\n\n\n- 関数・引数・戻り値\n関数(Function)とは、ある値を与えてある値を返すといった処理を部品化して再利用できるようにしたもの　　　　　　　　\n関数の構造は、　型名　関数名(引数) {処理}　である　　\n型名: 計算結果を返すときに使う数値の種類のことである　　\n関数名: 関数の名前のこと　　\n引数: 関数に渡す数値の種類のことで、渡された数値をもとに計算を行なって結果を返す　　\n処理: 関数を終了させる際にはreturn文を使用する、なにも返さない場合は0を返す　　\n数学で言うと、y=2xの場合、xに2を入れたら4を返すような関数と言える\nこのとき、関数に与えるもの(x)を引数、関数から返される値(y)を戻り値と言う\nまた、最近では引数や戻り値のない処理のまとまりのことも関数と呼ぶ\n引数や戻り値がないことをC言語ではvoidで表現し、voidを返すという\nまた、voidや0は省略することが可能である\n\n- ライブラリ\n英語でlibraryと書くように、プログラムの書庫を思い浮かべるのが適切である\n誰かが書いたプログラミングコードを誰でも使えるようにしたものをライブラリと呼び、\nそれらを活用することで他の人が書いたコードを安易に実装することを可能としている\nC言語において、最初に書かれる　#include <stdio.h>　もライブラリの一つである\nこの一文を入れることで、printfやscanfなどといった機能を使うことが可能となる\n他にも、数学関数を簡単に用いることのできるmath.hであったり、時刻を呼び出すことのできるmath.hはC言語においてよく使われる\n外部ライブラリを使う際は、これらのライブラリを使用する際にCUIでコマンドラインツール(Homebrew, npm, Composerなど)と呼ばれるものを用いて、ライブラリをインストールする\nまた、PythonやJavaScriptが人気とされる理由に多くのライブラリが存在することが挙げられる\n\n- 代入\n変数に値(数値や、文字、数式など)を入れることである\n代入をする際に、値の型を指定することが必要である\n\n- \\n(バックスラッシュn)\n改行を表す\n\n- ヘッダファイル\nヘッダファイルとは、.hという拡張子で作られたファイルのことである\nプログラムが大きくなってくると、機能ごとに複数のファイルに分割を行う\nヘッダファイルには、関数宣言を記述する\nヘッダファイルをincludeする際は<>ではなく、ダブルクォーテーション\"\"で囲んで呼び出す\n\n- コマンド(ls, rm, mkdir, cd, rmdir)\n  * ls \nlist segmentsの略で、作業ディレクトリのファイルやフォルダを一覧表示する\n  *  rm\nremoveの略で、指定したファイルを削除する\n  *  mkdir\nmake directoryの略で、ディレクトリを新規作成する\n  *  cd\nchange directoryの略で、指定したPATHのディレクトリに移動する\n  *  rmdir\nremove directoryの略で、指定したディレクトリを削除する\n\n- コマンドによるファイル指定( [~/], [..], [.])\n~(チルダ)はユーザーのホームディレクトリ(ログインした際にいるディレクトリ)を示す\n/(スラッシュ)で階層を表す\n現在のディレクトリは ./で表し、一つ前(上)の階層は、../で表す\ncd .. で一つ上の階層へ移動、 cd ../.. で二つ上の階層へ移動\n\n- C言語の型(string, int, long, float, char)\n変数とは、データを格納しておく箱のことであり、それらの種類を示したものをデータ型と呼ぶ\n\n  * string\n文字列(単語や文章など文字の集まり)型\n  * int \n32ビットで表すことのできる整数(-2147483648 ～ 2147483647)型、範囲は約±21億\n  * long\n64ビットで表すことのできる整数(-9223372036854775808 〜 9223372036854775807)型\n  * float\n小数型(浮動小数点数型)\n  * char\n文字型\n\n- 型のキャスト\n型を宣言した際に用いたものとは異なる型に変換することである\n(型)式で変換を行うことができる\nfloat a = 1;\nint b = (int) a;\n\n- 条件、ループ\n* 条件\n条件分岐には、if文またはswitch文を用いる\n条件式に当てはまる場合、中括弧内の処理を実行してif文を抜ける\n```\nif(条件式) {\n} else if(条件式) {\n} else {\n}\n```\nまた、この際に用いる演算子として、 +(足し算)、-(引き算)、*(掛け算)、/(割り算)、%(余り)がある\n条件式では、=を二つ繋げて==として比較を表す\nswitch分では、switch(式)で式を指定し、それに当てはまる値が1の時、case1:といったように条件分岐を行う\n処理を抜ける際はbreak,また、どの条件にも当てはまらない時はdefault:で処理を指定する\n```\nswitch(式){\n    case 定数:\n        処理;\n        breack;\n    default:\n        処理;\n}\n```\n* ループ\nループには、while文またはfor文を用いる\nwhile文の場合、条件式に当てはまる場合、中括弧内の処理を永遠にループする\n```\nwhile(条件式) {\n}\n```\n\n- ブール式\nboolとは、ブーリアン型(Boolean datatype)であり、真理値(true: 真、false: 偽)の2つの値を取る\n\n\n\n",
      "body_updated_at": "2021-11-13"
    },
    {
      "author": "nyarufoy",
      "created_at": "2021-11-20",
      "body_markdown": "# Lecture2\n[CS50 Lecture2 Arrays](https://www.youtube.com/watch?v=ZPIUlWrQ1ZA)\n\n# 重要キーワード\n- make\nmakeは、C言語などコンパイル型のプログラミング言語で記述されたプログラムを容易にビルドするためのツールである。CS50においては、clangと呼ばれるコマンドの実行の自動化を行なっている。\nclangを用いることでソースコードを実行可能な機械語に翻訳している(コンパイル)\nアセンブリ出力(assembly output)を表す、a.outファイルが生成される\n```\n$ clang -o test test.c\n```\n与えられたtestにtest.cを翻訳したもの(実行可能なファイル)を出力結果に返すという意味\n何も指定しなければ、a.outファイルが作成される\n\n- コンパイル(Week1より詳しい手順)\nソースコード → アセンブリ言語 → 機械語\n過程で、#から始まるヘッダファイルを検索し、読み込んだプログラムをソースコードに落とし込む\nつまり、#で横見込まれた複数のファイルを全て組み合わせて出力を行なっている\nただし、ヘッダーファイルは事前にコンパイラされたものがコンピュータの内部に保存されている(?)\n\n- デバッグ、ブレークポイント、コールスタック\nデバッグ: バグ(プログラムの誤り)の原因を探して修正を行うこと\n昔、コンピュータの内部に虫が混入してしまったことでシステムに不具合が生じたことがバグの語源である\nブレークポイント: プログラムを実行する際に、強制的に実行を一旦停止する箇所のことを示す\nコールスタック: どの関数が現在実行されているのか、その関数の中でどの関数が呼び出されたかを示す\n一度コードをコンパイルし、ブレークポイント(コードの実行を一時停止する場所を設定した後、コード上でデバッグを実行する)で\n\n- 配列\n値を入れることができる連続したメモリの塊のこと\n配列のインデックスは0から始まり、3つの数値を格納したい場合、 int scores[要素数] = {1, 2, 3};といった形で記述する。\n\n- 文字\nアルファベットなどの半角文字のことである\n文字型charは1バイトの情報量であるため、ASCII文字以外のひらがなや漢字などの代入はできない\nシングルクォーテーションで括るのが一般的\nchar moji = 'A';\n\n- 文字列\n単語や文章など文字の集まりのことである\nC言語においては、stringというデータ型は存在しないので、CS50のライブラリを用いている\nダブルクォーテーションで括るのが一般的\nchar mojiretsu[5]= \"abcd\";\n文字列の場合、最後に文字列の終わりを表す \\n(NULL)が格納されるため、要素数を+1で表示する必要がある\n\n- コマンドライン引数\nプログラムを実行する際にプログラムに渡す値のことである\nコマンドライン(ターミナルなど)を用いて入力を行うため、コマンドライン引数と呼ばれる\n\n- 終了コード\n終了コードとは、プログラムや関数が戻す処理結果の値のことである\n",
      "body_updated_at": "2021-12-04"
    },
    {
      "author": "nyarufoy",
      "created_at": "2021-11-27",
      "body_markdown": "# Lecture3\n[CS50 Lecture3 Algorithms](https://www.youtube.com/watch?v=Y0A0RX-FDBw)\n\n# 重要キーワード\n- データ構造\n- 線形探索\n線形探索とは、左から右、あるいは同等に右から左に検索する一番シンプルな探索である\n一般的には左から右へ探索することが多い\nとりあえず何か要素を見つけたいときに使われる\n上限: O(n)\n下限: Ω(1)\n\n- バイナリ検索(二分探索)\n要素が順番通りに既にソートされている場合に使える探索\n真ん中と比較して、それよりも大きいか、小さい要素であるかを確認を繰り返す探索である\n上限: O(log n)\n下限: Ω(1)\n\n- 構造体\n何らかの構造を持つデータ型のこと\ntypedef と struct を用いることで、他の複数のデータ型を組み合わせた構造を持つ独自のデータ型を作ることができる。下記コードだと、personというカスタムデータ型を生成している\n構造体を使うことで、データのつながりがわかりやすくなり、エラーを減らすことができる\n```c\ntypedef struct\n{\n     string name;\n     string number;\n}\nperson;\n```\n\n- ソート\n- 選択ソート\n最小の要素を何度も選択することでソートする\n最小の要素を見つけるために、配列の左から右に向かって与えられたデータ全ての要素と比較を行わないといけないのが欠点\n上限: O(n^2)\n下限: Ω(n^2)\n\n- バブルソート\n最大の数字がリストの一番上(最後)に向かって泡のように押し寄せていくことからバブルソートと呼ばれる\n隣同士の要素を比較して、大きさが降順になっていた場合にそれぞれを入れ替えていく\n与えられた要素によって、計算量が左右されやすいのが問題\n上限: (n-1)(n-1) = n^2 - 2n + 1 = O(n^2)\n下限: Ω(n)\n\n- 再帰\nsum(n): 0からnまでの数の合計を返す関数　を考える\n再帰的というのは、プログラムの中で同じ処理を繰り返しているときに、到達した点から逆向きに値を渡していくことで、最終的に求めたい値を求めることができる( 数学で言うと、漸化式のようなもの)\n同じような処理を階層の中で繰り返して行なっていく\n関数の中で同じ関数を呼び出すことができるようなプログラム\n\n```\n>>> sum(3)\nsum(3) = 3 + sum(2)\nsum(2) = 2 + sum(1)\nsum(1) = 1 + sum(0)\nsum(0) = 0\n```\n\n\n- マージソート\n2つの数列を併合していくソート\n細かいグループにどんどん分けていき、その中でソートを行なって、小さな枠組みマージをしていく\nまた、それぞれの要素を比較してより大きな枠組みでマージを行なっていく",
      "body_updated_at": "2021-12-04",
      "children": [
        {
          "author": "nyarufoy",
          "created_at": "2021-12-02",
          "body_markdown": "## runoff\n決選投票問題\n- 有権者は自分の好みの候補者をランク付けする\n- 候補者が過半数の票を獲得した場合、その候補者が勝者となる\n- そうでなければ、得票数の少ない候補者を排除し、その候補者なしで選挙をやり直す\n\n```diff:実行例\n./runoff Alice Bob Charlie\nNumber of voters: 5\nRank 1: Alice\nRank 2: Bob\nRank 3: Charlie\n\nRank 1: Alice\nRank 2: Charlie\nRank 3: Bob\n\nRank 1: Bob\nRank 2: Charlie\nRank 3: Alice\n\nRank 1: Bob\nRank 2: Alice\nRank 3: Charlie\n\nRank 1: Charlie\nRank 2: Alice\nRank 3: Bob\n\nAlice\n```\n![](https://storage.googleapis.com/zenn-user-upload/0a5365f4a3af-20211202.png =400x)\n\n![](https://storage.googleapis.com/zenn-user-upload/9e4eb553f590-20211202.png =400x)\n\n## 準備\n```\n$wget https://cdn.cs50.net/2020/fall/psets/3/runoff/runoff.c\n```\n\n## コーディング\n- vote関数の実装\nname(投票された名前)が候補者の名前と一致する時、preferencesを更新する\n投票者iのj番目の投票に立候補者のインデックス(candidate_count)を入れる\n\n- tabulate関数の実装\n脱落者でないかどうかを判断し、脱落者でない時、投票数をプラスする\n\n- print_winner関数の実装\n候補者が過半数の表を持っている場合、その名前をstdoutに出力し、関数はtrueを返す\n誰も選挙に勝っていない場合は、関数はfalseを返す\n\n- find_min関数の実装\n選挙に残っている候補者の最小投票総数を返す\n候補者をループして、選挙に残っているかつ投票数が最も少ない候補者を探す\n\n- is_tie関数の実装\n選挙に残っている全ての候補者の投票数が同じ場合はtrueを返し、そうでない場合はfalseを返す\nまた、この関数は引数min(候補者の最小投票数)を受け取っている\n\n- eliminate関数の実装\n投票数がminとなる候補者を除外する\n\n\n\n",
          "body_updated_at": "2021-12-03"
        },
        {
          "author": "nyarufoy",
          "created_at": "2021-12-02",
          "body_markdown": "### tideman\n順位選択制選挙\n- Tally : 有権者が候補者のランク付けを行ったら、候補者のペアごとに勝者を決定する\n- Sort： 候補者のペアを勝率の高い順に並べ替える(降順でソート)\n- Lock：最も強いペアから順に候補のペアを調べ、そのペアを固定してもグラフにサイクルが生じない場合、各ペアを候補者グラフに固定していく\n- グラフの開始点となる人が選挙の勝者である\n\n```diff:実行例\n./tideman Alice Bob Charlie\nNumber of voters: 5\nRank 1: Alice\nRank 2: Charlie\nRank 3: Bob\n\nRank 1: Alice\nRank 2: Charlie\nRank 3: Bob\n\nRank 1: Bob\nRank 2: Charlie\nRank 3: Alice\n\nRank 1: Bob\nRank 2: Charlie\nRank 3: Alice\n\nRank 1: Charlie\nRank 2: Alice\nRank 3: Bob\n\nCharlie\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/a7a5566092e5-20211202.png =400x)\n![](https://storage.googleapis.com/zenn-user-upload/6631f38d61b0-20211202.png =400x)\n![](https://storage.googleapis.com/zenn-user-upload/e6a939d2b8d7-20211202.png =400x)\n![](https://storage.googleapis.com/zenn-user-upload/0f5f6f1ce494-20211202.png =400x)\n\n\n### 事前準備\n```\n$ wget https://cdn.cs50.net/2020/fall/psets/3/tideman/tideman.c\n```\n\n### コーディング\n- candidates \n  * 候補者名の配列\n- preferences\n  * 二次元配列\n  * preferences[i][j]は、候補者jよりも候補者iを好む有権者の数\n![](https://storage.googleapis.com/zenn-user-upload/b118785fe7a7-20211203.png =400x)\n\n- pairs\n  * ある候補者が他の候補者よりも優先されるすべてのペアの配列\n- locked\n  * 候補者のグラフを表す2次元ブーリアン配列\n  * locked[i][j]は、候補者iから候補者jへのadgeポイントを固定したことを意味する\n\n- vote関数の実装\nname(投票された名前)が候補者の名前と一致する時、配列ranksを更新する\nranks[i]は投票者のi番目の選好を表す\nranksを正常に更新できた場合、この関数はtrueを返し、そうでない場合(nameが候補者ではなかった場合)はfalseを返す\n\n- record_preferences関数を実装\nグローバル関数preferencesを更新して現在の投票者の選考を追加する\npreferences[i][j]は、候補者jよりも候補者iを好む投票者の数を表す必要がある\n\n- add_pairs関数を実装\nグローバル変数pair_countを更新して、候補者のペアの数にする必要がある\n(ペアは全てpairs[0]~pairs[pairs_count - 1]に格納する)\nどの候補者が優先されているかについて、配列pairsに全ての候補者のペアを追加する\n引き分けの候補者ペアは配列に追加しない\n\n- sort_pairs関数を実装\n選択された候補者を好む投票者の数を勝利の要因と定義し、勝利の高い順(降順)で配列pairsをソートする。複数のペアが同じ強さである場合、順序はどちらでも良いと考える\n\n- lock_pairs関数を実装\nロックされたグラフlockedを作成し、矢印がサイクルを作成していない場合に限り、全ての矢印を勝利順(降順)で追加する\n\n- print_winner関数を実装\nグラフの開始点である候補者の名前を出力する\n複数の開始点が存在しないと想定する",
          "body_updated_at": "2021-12-03"
        }
      ]
    },
    {
      "author": "nyarufoy",
      "created_at": "2021-12-04",
      "body_markdown": "# Lecture2\n[CS50 Lecture4 Memory](https://youtu.be/a-L1GMVMZok)\n\n# 重要キーワード\n- 16進数\n16進数は10進数で表す0-9までを0-9で表し、10-16までの値をA-Fを用いて16を表現する。\n\n\n- アドレス、ポインタ\n- C言語における文字列(string)の扱い\n- 文字列(string)の比較とコピー\n- メモリリーク\n- malloc, free\nmallocは、メモリを確保し、使用可能なメモリの最初のバイトのアドレスを与える。\nfreeは、メモリをオペレーティングシステムに私、使い終わったことを知らせるためのもの。\n一度使用したメモリを解放することができるため、他の変数に再利用が可能。\nmallocを使用した際は最後にfreeを用いてメモリ不足を解消する必要がある。\n```\n$ vali\n```\n- ゴミのような値\n自分自身がメモリのどこかに値を入れていない場合、安全のために、それは引用符で囲まれたゴミのような値と考えるべきである。\n\n- グローバル変数\n- malloc\n- ヒップ、ヒップオーバーフロー\n- スタック、スタックオーバーフロー\n- C言語におけるファイルの扱い",
      "body_updated_at": "2021-12-04",
      "children": [
        {
          "author": "nyarufoy",
          "created_at": "2021-12-04",
          "body_markdown": "- 16進数とはどのようなものか、どのように使われているのか\n16進数とは、16を基数(ベース)として表した数値のことを指す。\n16個(プログラムなので、0から考えて0から15まで)の数字を1桁で表すことが出来るのが16進数であり、15を超えた時に桁が繰り上げとなる。\n10進数で表す0-9までを0-9で表し、10-16までの値をA-Fを用いて16を表現する。\n\n- ポインタとアドレスとは何か\nポインタとは、変数のアドレスを格納することができる変数のことである。\n*(アスタリスク)を使うことで、ポインタ型の変数であることを示すことができる。\nアドレスとは、メモリ状に与えられた番号、住所のようなものである。\n&(アンパサンド)を使うことで、メモリのどこに位置しているか(アドレス)を確かめることができる。\n\n- C言語において文字列(string)は、変数には実際には何が保存されているか\n文字列(string)は実際には文字列の、最初の文字のアドレスを持つ単なるポインタのことである。\n実際には、char *で表すことができる。\n\n- 文字列(string)同士を比較またはコピーするにはどうすればよいか\nstrcpyを用いてstring型で宣言した変数の値を比較、コピーを行うことができる。\nまたは、for文などのループ、mallocを用いてアドレスをコピーする二種類の方法がある。\nC言語にはさまざまなライブラリが既に実装されていて、文字列(string, char *)はstrcpyという関数で簡単にコピーが行える\n\n- (難) メモリリークとは何か\nメモリを確保した後に解放し忘れること\n\n- (難) ヒープ、ヒープオーバーフローとは何か\n\n\n- (難) スタック、スタックオーバーフローとは何か\n\n",
          "body_updated_at": "2021-12-04"
        }
      ]
    }
  ]
}